name: Sonar Scan

permissions:
  pull-requests: write
  contents: write
  issues: write

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches: [ main ]

  push:
    branches:
      - main

jobs:
  sonar:
    name: SonarQube Scan (action) + Quality Gate check
    runs-on: ubuntu-latest
    environment: login_page_env
    env:
      SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Validate Sonar secrets (fail early)
        run: |
          if [ -z "${SONAR_HOST_URL}" ] || [ -z "${SONAR_TOKEN}" ] || [ -z "${SONAR_PROJECT_KEY}" ]; then
            echo "ERROR: SONAR_HOST_URL, SONAR_TOKEN, SONAR_PROJECT_KEY must be set as secrets/vars."
            exit 1
          fi
          if [[ ! "${SONAR_HOST_URL}" =~ ^https?:// ]]; then
            echo "ERROR: SONAR_HOST_URL must include http:// or https://"
            exit 1
          fi
          echo "Sonar config looks good."

      - name: Run SonarQube Scan (official action)
        uses: sonarsource/sonarqube-scan-action@v3
        env:
          SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}

      - name: Ensure jq is available (for polling JSON)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Wait for Sonar analysis & check Quality Gate
        env:
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          set -euo pipefail
          echo "ðŸ”Ž Locating report-task.txt (written by the scanner)..."

          ANALYSIS_ID=""
          CE_URL=""

          # --- Look for report-task.txt in .scannerwork ---
          if [ -f report-task.txt ]; then
            REPORT_FILE="report-task.txt"
          elif [ -f .scannerwork/report-task.txt ]; then
            REPORT_FILE=".scannerwork/report-task.txt"
          else
            REPORT_FILE=$(find . -type f -path "*/.scannerwork/report-task.txt" | head -n1 || true)
          fi

          if [ -n "${REPORT_FILE}" ] && [ -f "${REPORT_FILE}" ]; then
            echo "âœ… Found report-task.txt at: ${REPORT_FILE}"
            cat "${REPORT_FILE}"
            CE_URL=$(grep '^ceTaskUrl=' "${REPORT_FILE}" | cut -d'=' -f2- || true)
            ANALYSIS_ID=$(grep '^analysisId=' "${REPORT_FILE}" | cut -d'=' -f2- || true)
          else
            echo "âš ï¸  report-task.txt NOT found. Falling back to projectKey polling."
          fi

          sonar_api() {
            local path="$1"
            curl -s -u "${SONAR_TOKEN}:" "${SONAR_HOST_URL%/}${path}"
          }

          # Poll CE task
          if [ -n "${CE_URL}" ]; then
            echo "Polling Compute Engine task at: ${CE_URL}"
            for i in $(seq 1 60); do
              TASK_JSON=$(curl -s -u "${SONAR_TOKEN}:" "${CE_URL}")
              status=$(echo "$TASK_JSON" | jq -r '.task.status // empty')
              echo "  attempt $i - task.status=${status}"
              if [ "${status}" = "SUCCESS" ]; then
                ANALYSIS_ID=$(echo "$TASK_JSON" | jq -r '.task.analysisId // empty')
                break
              fi
              if [ "${status}" = "FAILED" ]; then
                echo "âŒ CE task failed. Continuing anyway for testing."
                break
              fi
              sleep 5
            done
          fi

          # Fetch Quality Gate
          echo "Fetching Quality Gate status..."
          if [ -n "${ANALYSIS_ID}" ]; then
            QG_JSON=$(sonar_api "/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}")
          else
            QG_JSON=$(sonar_api "/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}")
          fi
          echo "$QG_JSON" | jq .

          QG_STATUS=$(echo "$QG_JSON" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "Final Quality Gate status: ${QG_STATUS}"

          if [ "${QG_STATUS}" = "OK" ]; then
            echo "âœ… Quality Gate passed."
          else
            echo "âš ï¸ Quality Gate failed or unknown (status=${QG_STATUS})."
            echo "  Ignoring failure for CI pass (testing mode)."
          fi

          # Always exit 0 to not break workflow
          exit 0

      - name: Fetch SonarQube PR analysis & Post Sonar summary as PR comment
        if: ${{ github.event_name == 'pull_request' }}
        env:
          BASE: ${{ secrets.SONAR_HOST_URL }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          BASE="${BASE%/}"
          echo "Fetching Sonar data for project=${SONAR_PROJECT_KEY}, PR=${PR_NUMBER}"

          mkdir -p sonar_data

          # Fetch project quality gate
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" \
            -o sonar_data/qg.json || echo "{}" > sonar_data/qg.json

          # Fetch key measures
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/measures/component?component=${SONAR_PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density" \
            -o sonar_data/measures.json || echo "{}" > sonar_data/measures.json

          # 1) Try PR-scoped issues first (most relevant for PR reviews)
          curl -s -u "${SONAR_TOKEN}:" \
            "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&pullRequest=${PR_NUMBER}&ps=20" \
            -o sonar_data/issues_pr.json || echo "{}" > sonar_data/issues_pr.json

          # 2) If PR-scoped returned none, fallback to component-wide issues (wider scan)
          HAS_PR_ISSUES=$(jq -r '(.issues | length) // 0' sonar_data/issues_pr.json 2>/dev/null || echo "0")
          if [ "${HAS_PR_ISSUES}" -eq 0 ]; then
            echo "No PR-scoped issues found; fetching component-wide issues as fallback..."
            curl -s -u "${SONAR_TOKEN}:" \
              "${BASE}/api/issues/search?componentKeys=${SONAR_PROJECT_KEY}&ps=50" \
              -o sonar_data/issues_component.json || echo "{}" > sonar_data/issues_component.json
            ISSUES_FILE="sonar_data/issues_component.json"
          else
            ISSUES_FILE="sonar_data/issues_pr.json"
          fi

          echo "## ðŸ›°ï¸ SonarQube Summary for PR #${PR_NUMBER}" > sonar_comment.md
          echo "" >> sonar_comment.md

          # --- QUALITY GATE ---
          echo "### ðŸ§­ Quality Gate" >> sonar_comment.md
          if jq -e '.projectStatus' sonar_data/qg.json >/dev/null 2>&1; then
            jq -r '.projectStatus | "- **Status:** " + (.status // "UNKNOWN")' sonar_data/qg.json >> sonar_comment.md
            if jq -e '.projectStatus.conditions' sonar_data/qg.json >/dev/null 2>&1; then
              echo "" >> sonar_comment.md
              echo "- **Conditions:**" >> sonar_comment.md
              jq -r '.projectStatus.conditions[] | "  - " + (.metricKey // "unknown") + ": " + (.status // "UNKNOWN") + " (actual: " + ((.actual.value // "null")|tostring) + ")"' sonar_data/qg.json >> sonar_comment.md
            fi
          else
            echo "- (Quality gate unavailable)" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- KEY METRICS ---
          echo "### ðŸ“Š Key Metrics" >> sonar_comment.md
          if jq -e '.component.measures' sonar_data/measures.json >/dev/null 2>&1; then
            jq -r '.component.measures[] | "- " + .metric + ": " + (.value // "null")' sonar_data/measures.json >> sonar_comment.md
          else
            echo "- (metrics unavailable)" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- TOP ISSUES ---
          echo "### âš ï¸ Top Sonar Issues" >> sonar_comment.md

          if jq -e '.issues' "${ISSUES_FILE}" >/dev/null 2>&1; then
            COUNT=$(jq -r '(.issues | length) // 0' "${ISSUES_FILE}")
            if [ "$COUNT" -eq 0 ]; then
              echo "_No Sonar issues returned for this query._" >> sonar_comment.md
            else
              echo "" >> sonar_comment.md
              echo "| Severity | Rule | Location | Message |" >> sonar_comment.md
              echo "|---|---|---|---|" >> sonar_comment.md
              # Sort by severity (string sort) then show first 20 results - truncate messages to 300 chars
              jq -r '.issues | sort_by(.severity) | reverse | .[0:20] | .[] |
                ("| " + (.severity // "INFO") +
                 " | " + (.rule // "unknown") +
                 " | " + ((.component // "unknown") + (if .line then ":" + (.line|tostring) else "" end)) +
                 " | " + ((.message // "") | gsub("\n"; " ") | .[0:300]) + " |")' "${ISSUES_FILE}" >> sonar_comment.md
            fi
          else
            echo "_Failed to parse issues JSON or none returned._" >> sonar_comment.md
          fi
          echo "" >> sonar_comment.md

          # --- SONAR DASHBOARD LINK ---
          if grep -q '^dashboardUrl=' .scannerwork*/report-task.txt 2>/dev/null; then
            DASH=$(grep '^dashboardUrl=' .scannerwork*/report-task.txt 2>/dev/null | cut -d'=' -f2- | head -n1)
            echo "[ðŸ”— View full results in SonarQube Dashboard](${DASH})" >> sonar_comment.md
          fi

          echo "=== sonar_comment.md preview ==="
          sed -n '1,200p' sonar_comment.md || true

          # --- POST COMMENT TO GITHUB ---
          PAYLOAD=$(jq -Rs --arg body "$(cat sonar_comment.md)" '{body: $body}')
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "$API" \
            && echo "âœ… Posted Sonar summary comment to PR #${PR_NUMBER}."